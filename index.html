import tkinter as tk
from tkinter import messagebox
from datetime import datetime

# --- Financial Constants (Simplified and illustrative, based on known Singapore policies) ---

class IncomeCalculator:
    """
    Calculates net income, CPF contribution (age-dependent), PCTS amount,
    and WIS eligibility based on Singapore's Platform Worker schemes (2025-2028).
    
    NOTE: The CPF rates used here are simplified projections for demonstration.
    Real-world rates are highly complex and depend on both age and year.
    """

    # Deduction rates based on the fixed expense deductible tiers (1, 2, 3)
    # Tier 1: Low deduction, Tier 3: High deduction (e.g., for car/van use)
    DEDUCTION_RATES = {
        2025: {1: 0.20, 2: 0.35, 3: 0.60},
        2026: {1: 0.20, 2: 0.35, 3: 0.60},
        2027: {1: 0.20, 2: 0.35, 3: 0.60},
        2028: {1: 0.20, 2: 0.35, 3: 0.60}
    }

    # PCTS rates (Percentage of income contributed to tax scheme)
    PCTS_RATES = {
        2025: 0.025, 
        2026: 0.050 * 0.75, # Example phase-in rate
        2027: 0.070 * 0.50,
        2028: 0.090 * 0.25
    }

    # CPF Rates (Employee Share for Platform Workers CPF Transition)
    # The rates are simplified based on age band for the given year.
    CPF_RATES = {
        2025: {'55_and_below': 0.135, 'above_55': 0.090},
        2026: {'55_and_below': 0.155, 'above_55': 0.100},
        2027: {'55_and_below': 0.180, 'above_55': 0.110},
        2028: {'55_and_below': 0.200, 'above_55': 0.120}
    }

    def __init__(self, year, year_of_birth, earn_income, deduction_tier, type_of_mode):
        """Initializes the calculator with parameters."""
        self.year = year
        self.year_of_birth = year_of_birth
        self.earn_income = earn_income
        self.deduction_tier = deduction_tier # Maps to fixed_expense_deductable_amount
        self.type_of_mode = type_of_mode     # Used for the 1.1x multiplier check

    def calculate_age(self):
        """Calculates the worker's age in the specified calculation year."""
        current_year = datetime.now().year
        # Use the calculation year to determine the age for correct CPF band lookup
        return self.year - self.year_of_birth

    def calculate_net_income(self):
        """Calculates the net income after deducting the fixed expense."""
        
        # 1. Get the base deduction rate based on the tier
        deduction_rate = self.DEDUCTION_RATES.get(self.year, {}).get(self.deduction_tier, 0)

        # 2. Adjust deduction rate based on type of mode (Type 2 gets a 10% increase in deduction)
        # Type 2 is typically for motorized PMDs, PABs, or motorcycles (from original code comments)
        if self.type_of_mode == 2:
            deduction_rate *= 1.1 

        net_income = self.earn_income * (1 - deduction_rate)
        return round(net_income, 2)

    def get_cpf_rate(self, age):
        """Retrieves the age-dependent CPF rate for the given year."""
        year_rates = self.CPF_RATES.get(self.year, {})
        
        # Age bands are crucial for Singapore's CPF system
        if age <= 55:
            return year_rates.get('55_and_below', 0)
        else:
            return year_rates.get('above_55', 0)

    def calculate_cpf_contribution(self):
        """Calculates the CPF contribution based on net income and age."""
        net_income = self.calculate_net_income()
        age = self.calculate_age()

        cpf_rate = self.get_cpf_rate(age)
        
        # Contribution is capped, but for this simplified model, we use the simple rate multiplication.
        return round(net_income * cpf_rate, 2)

    def calculate_pcts_amount(self, net_income):
        """Calculates the PCTS amount. PCTS is not payable if income is too high."""
        # PCTS (Platform Centralised Tax Scheme) eligibility threshold (Illustrative)
        PCTS_THRESHOLD = 3000 

        if net_income >= PCTS_THRESHOLD:
            return 0
            
        pcts_rate = self.PCTS_RATES.get(self.year, 0)
        return round(net_income * pcts_rate, 2)

    def calculate_wis_eligibility(self, net_income):
        """Determines Workfare Income Supplement (WIS) eligibility based on net income."""
        # WIS Eligibility is defined by a monthly income range (Illustrative)
        MIN_INCOME_WIS = 500
        MAX_INCOME_WIS = 3000
        
        if MIN_INCOME_WIS <= net_income <= MAX_INCOME_WIS:
            return "eligible"
        else:
            return "not eligible"

    def get_results(self):
        """Returns all calculated results."""
        net_income = self.calculate_net_income()
        
        pcts_amount = self.calculate_pcts_amount(net_income)
        cpf_contribution = self.calculate_cpf_contribution()
        wis_eligibility = self.calculate_wis_eligibility(net_income)
        
        return net_income, pcts_amount, cpf_contribution, wis_eligibility


# --- Tkinter Application (GUI) ---

class MenuApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Platform Worker Financial Calculator (SG)")
        self.geometry("450x550")
        self.config(padx=20, pady=20)
        
        # Ensure the Tkinter validator is registered
        self.int_validate_cmd = self.register(self._validate_input)
        
        self._setup_ui()

    def _setup_ui(self):
        """Sets up the input and output frames."""
        
        # Header
        tk.Label(self, text="Platform Worker CPF & Benefits", font=("Arial", 16, "bold"), fg="#1e3a8a").pack(pady=(0, 15))

        # --- Input Frame (Blue-100 equivalent) ---
        self.input_frame = tk.Frame(self, padx=10, pady=10, bg="#dbeafe", bd=1, relief=tk.RIDGE)
        self.input_frame.pack(fill=tk.X, pady=10)
        
        tk.Label(self.input_frame, text="Input Parameters", font=("Arial", 12, "bold"), bg="#dbeafe").grid(row=0, columnspan=2, pady=(0, 10))

        # Input variables
        self.year_var = tk.StringVar(self, value="2025")
        self.earn_income_var = tk.StringVar(self, value="")
        self.year_of_birth_var = tk.StringVar(self, value="")
        self.type_of_mode_var = tk.StringVar(self, value="1") # 1 or 2 for multiplier check

        # 1. Year Selection
        self._create_input(self.input_frame, "Year:", 1, [2025, 2026, 2027, 2028], self.year_var)

        # 2. Earn Income (Monthly)
        tk.Label(self.input_frame, text="Monthly Earn Income ($):", anchor="w").grid(row=2, column=0, sticky="w", pady=5)
        self.earn_income_entry = tk.Entry(self.input_frame, textvariable=self.earn_income_var, validate="key", validatecommand=(self.int_validate_cmd, '%P', '%W'))
        self.earn_income_entry.grid(row=2, column=1, sticky="ew", pady=5, padx=5)

        # 3. Year of Birth
        tk.Label(self.input_frame, text="Year of Birth:", anchor="w").grid(row=3, column=0, sticky="w", pady=5)
        self.year_of_birth_entry = tk.Entry(self.input_frame, textvariable=self.year_of_birth_var, validate="key", validatecommand=(self.int_validate_cmd, '%P', '%W'))
        self.year_of_birth_entry.grid(row=3, column=1, sticky="ew", pady=5, padx=5)
        
        # 4. Deduction Tier (Maps to fixed_expense_deductable_amount)
        # We simplify the original two confusing fields into two clearer ones.
        deduction_options = {
            1: "Tier 1: Foot/Public Transport (Rate 20%)",
            2: "Tier 2: PMD/PAB/Motorcycle (Rate 35%)",
            3: "Tier 3: Car/Van (Rate 60%)"
        }
        self.deduction_tier_var = tk.StringVar(self, value=deduction_options[3]) # Default to highest rate
        self._create_input(self.input_frame, "Deduction Tier:", 4, deduction_options.values(), self.deduction_tier_var)
        
        # 5. Type of Mode (For 1.1x multiplier check - original code logic)
        self._create_input(self.input_frame, "Motorized Mode Multiplier (10%):", 5, {"1": "No Multiplier", "2": "Apply Multiplier (Mode 2)"}.values(), self.type_of_mode_var)
        
        # Calculate Button
        self.calculate_btn = tk.Button(self.input_frame, text="Calculate", command=self._calculate_results, 
                                       bg="#10b981", fg="white", font=("Arial", 12, "bold"), relief=tk.RAISED)
        self.calculate_btn.grid(row=6, columnspan=2, sticky="ew", pady=15, padx=5)


        # --- Output Frame (Yellow-100 equivalent) ---
        self.output_frame = tk.Frame(self, padx=10, pady=10, bg="#fef9c3", bd=1, relief=tk.RIDGE)
        self.output_frame.pack(fill=tk.X, pady=10)
        
        tk.Label(self.output_frame, text="Calculation Results", font=("Arial", 12, "bold"), bg="#fef9c3").grid(row=0, columnspan=2, pady=(0, 10))

        # Result Labels
        self.net_income_value = self._create_output(self.output_frame, "Net Income:", 1)
        self.cpf_contribution_value = self._create_output(self.output_frame, "CPF Contribution:", 2)
        self.pcts_amount_value = self._create_output(self.output_frame, "PCTS Amount:", 3)
        self.wis_eligibility_value = self._create_output(self.output_frame, "WIS Eligibility:", 4)

        self.input_frame.grid_columnconfigure(1, weight=1) # Make entry field expand

    def _create_input(self, parent, label_text, row, options, var):
        """Helper to create a label and OptionMenu/Entry."""
        tk.Label(parent, text=label_text, anchor="w", bg=parent['bg']).grid(row=row, column=0, sticky="w", pady=5)
        
        if isinstance(options, list):
            options = [str(o) for o in options]
            
        dropdown = tk.OptionMenu(parent, var, *options)
        dropdown.config(width=25)
        dropdown.grid(row=row, column=1, sticky="ew", pady=5, padx=5)
        return dropdown

    def _create_output(self, parent, label_text, row):
        """Helper to create an output label pair."""
        tk.Label(parent, text=label_text, anchor="w", bg=parent['bg']).grid(row=row, column=0, sticky="w", pady=5)
        
        value_label = tk.Label(parent, text="--.--", anchor="e", font=("Arial", 10, "bold"), bg=parent['bg'], fg="#10b981")
        value_label.grid(row=row, column=1, sticky="e", pady=5, padx=5)
        return value_label

    def _validate_input(self, P, W):
        """Validates if the input is a valid number (integer or float equivalent)."""
        widget = self.nametowidget(W)
        if P == "":
            widget.config(bg='red', fg='white') # Highlight empty field
            return True # Allow deletion
        
        try:
            float(P)
            widget.config(bg='white', fg='black') # Clear highlight on valid input
            return True
        except ValueError:
            return False # Reject non-numeric input

    def _clear_errors(self):
        """Resets background and foreground colors for entry fields."""
        self.earn_income_entry.config(bg='white', fg='black')
        self.year_of_birth_entry.config(bg='white', fg='black')

    def _calculate_results(self):
        """Handles the calculation process when the button is clicked."""
        self._clear_errors() # Always clear previous errors first
        
        try:
            # 1. Input Validation and Conversion
            year = int(self.year_var.get())
            
            try:
                earn_income = float(self.earn_income_var.get())
                if earn_income < 0: raise ValueError
            except ValueError:
                self.earn_income_entry.config(bg='red', fg='white')
                messagebox.showerror("Input Error", "Please enter a valid, non-negative Monthly Earn Income.")
                return

            try:
                year_of_birth = int(self.year_of_birth_var.get())
                current_year = datetime.now().year
                if not (1900 < year_of_birth <= current_year): raise ValueError
            except ValueError:
                self.year_of_birth_entry.config(bg='red', fg='white')
                messagebox.showerror("Input Error", f"Please enter a valid Year of Birth (e.g., between 1900 and {current_year}).")
                return
            
            # Extract deduction tier number from the dropdown string
            # e.g., "Tier 3: Car/Van (Rate 60%)" -> 3
            deduction_tier_str = self.deduction_tier_var.get()
            deduction_tier = int(deduction_tier_str.split(':')[0].replace('Tier ', '').strip())
            
            # Type of mode (1 or 2) for multiplier check
            type_of_mode_str = self.type_of_mode_var.get()
            type_of_mode = int(type_of_mode_str.split(' ')[0].strip())


            # 2. Calculation
            calculator = IncomeCalculator(
                year=year,
                year_of_birth=year_of_birth,
                earn_income=earn_income,
                deduction_tier=deduction_tier,
                type_of_mode=type_of_mode
            )
            
            net_income, pcts_amount, cpf_contribution, wis_eligibility = calculator.get_results()

            # 3. Display Results
            self.net_income_value.config(text=f"$ {net_income:,.2f}", fg="#10b981")
            self.pcts_amount_value.config(text=f"$ {pcts_amount:,.2f}", fg="#10b981")
            self.cpf_contribution_value.config(text=f"$ {cpf_contribution:,.2f}", fg="#10b981")
            
            wis_color = "green" if wis_eligibility == 'eligible' else "red"
            self.wis_eligibility_value.config(text=wis_eligibility.upper(), fg=wis_color)

        except Exception as e:
            messagebox.showerror("Fatal Error", f"An unexpected error occurred during calculation: {e}")
            # Ensure all output labels show error state
            self.net_income_value.config(text="Error", fg="red")
            self.cpf_contribution_value.config(text="Error", fg="red")
            self.pcts_amount_value.config(text="Error", fg="red")
            self.wis_eligibility_value.config(text="Error", fg="red")
            print(f"Calculation error: {e}")

if __name__ == "__main__":
    app = MenuApp()
    app.mainloop()

